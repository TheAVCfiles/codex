<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PyRouette Studio Composer — Demo</title>
  <meta name="description" content="PyRouette Studio Composer — Live choreography builder: code → stage, export rehearsal schedules, Labanotation-ready payloads." />
  <link rel="icon" href="./assets/favicon.ico" />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Inter:wght@300;400;600&display=swap');
    :root{--bg:#080708;--muted:#9ca3af;--gold:#c59a5b;--accent:#0ea86f}
    body{background:var(--bg);color:#e6eef2;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
    .serif{font-family:'Playfair Display',serif}
    .stage-grid{background:linear-gradient(180deg,#050504 0,#0b0b0b 100%);border-radius:.5rem;padding:1rem}
    .cell{width:56px;height:56px;border:1px solid rgba(255,255,255,0.04);display:flex;align-items:center;justify-content:center;position:relative}
    .coord{position:absolute;left:4px;bottom:3px;font-size:10px;color:rgba(255,255,255,0.15)}
    /* Ensure dancers move smoothly */
    .dancer{width:34px;height:34px;border-radius:6px;display:flex;align-items:center;justify-content:center;font-weight:700;color:#071214;box-shadow:0 6px 18px rgba(0,0,0,0.6);transition:transform .5s linear, top .5s linear, left .5s linear}
    .token{padding:.25rem .4rem;border-radius:6px}
    .controls input, .controls textarea{background:#0a0a0a;border:1px solid rgba(255,255,255,0.04);color:#dbeafe;padding:.5rem;border-radius:.375rem}
    .btn{background:linear-gradient(90deg,var(--accent),#10b981);color:white;padding:.6rem .9rem;border-radius:.5rem;font-weight:700;transition: background-color 0.2s}
    .btn:hover{filter: brightness(1.1);}
    .meta{color:var(--muted);font-size:.9rem}
    .label{font-size:.8rem;color:rgba(255,255,255,0.6);letter-spacing:.06em}
    .role-badge{font-size:11px;padding:3px 6px;border-radius:999px;background:rgba(255,255,255,0.04);color:var(--muted)}
    .panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border:1px solid rgba(255,255,255,0.03);padding:1rem;border-radius:.6rem}
  </style>
</head>
<body class="min-h-screen flex items-center justify-center p-6">
  <div class="max-w-6xl w-full grid grid-cols-1 lg:grid-cols-2 gap-6">
    <!-- Left: Stage -->
    <section class="stage-grid panel">
      <div class="flex justify-between items-start mb-3">
        <div>
          <h1 class="serif text-2xl text-white">PyRouette Studio Composer</h1>
          <div class="meta">Live choreography builder — stage grid, role mapping, tempo validation, rehearsal schedule export</div>
        </div>
        <div class="text-right">
          <div class="label">Demo Mode</div>
          <div class="role-badge">Balanchine Edition · Luxe</div>
        </div>
      </div>

      <div class="flex gap-4">
        <div>
          <!-- stage labels -->
          <div class="mb-2 text-xs text-neutral-400">Stage: upstage at top • audience at bottom</div>
          <div id="stage" class="grid grid-cols-8 gap-0" style="width:448px">
            <!-- grid cells generated by JS -->
          </div>
          <div class="flex justify-between items-center mt-3 text-xs text-neutral-400">
            <span>Wings ⟵ ports & terminals</span>
            <span>Mirror (stage left)</span>
            <span>Curtain (downstage)</span>
          </div>
        </div>

        <div class="w-64">
          <div class="mb-3">
            <div class="label">Tempo</div>
            <input id="tempo" type="number" value="120" class="w-full mt-1" />
          </div>

          <div class="mb-3">
            <div class="label">Roles ↔ Chess Pieces</div>
            <div class="mt-1 text-sm">
              <div class="flex items-center justify-between"><span>King</span><span class="meta">Artistic Director</span></div>
              <div class="flex items-center justify-between"><span>Queen</span><span class="meta">Principal</span></div>
              <div class="flex items-center justify-between"><span>Rook</span><span class="meta">Soloist / Corps (anchor)</span></div>
              <div class="flex items-center justify-between"><span>Bishop</span><span class="meta">Contemporary Lead</span></div>
              <div class="flex items-center justify-between"><span>Knight</span><span class="meta">Cavalier / Specialist</span></div>
              <div class="flex items-center justify-between"><span>Pawn</span><span class="meta">Corps Member / Corps</span></div>
            </div>
          </div>

          <div>
            <div class="label">Birth Chart Ignition (comma list e.g. A:Sun=Scorpio)</div>
            <input id="charts" placeholder="A:Sun=Scorpio, B:Moon=Aquarius" class="w-full mt-1" />
            <div class="text-xs text-neutral-500 mt-1">Colors dancers by sign archetype — studio-only demo</div>
          </div>
        </div>
      </div>

      <div class="mt-4 flex items-center gap-3">
        <button id="exec" class="btn" style="background:linear-gradient(90deg,#0ea86f,#10b981)">Execute DSL</button>
        <button id="play" class="btn">Play Sequence</button>
        <button id="pause" class="btn" style="opacity:.9; background:linear-gradient(90deg,#94a3b8,#64748b)">Pause</button>
        <button id="exportSchedule" class="btn" style="background:linear-gradient(90deg,#c59a5b,#a56f3b)">Export Rehearsal</button>
        <button id="exportJSON" class="btn" style="background:linear-gradient(90deg,#64748b,#334155)">Export Notation</button>
      </div>
    </section>

    <!-- Right: Editor -->
    <aside class="panel">
      <div class="mb-3">
        <div class="label">PyRouette DSL — paste example & Execute</div>
        <textarea id="dsl" rows="12" class="w-full mt-2 font-mono text-sm" spellcheck="false"></textarea>
      </div>

      <div class="flex gap-2 mb-3">
        <!-- Moved Execute button above for better UX flow -->
        <button id="clear" class="btn" style="background:linear-gradient(90deg,#374151,#111827)">Clear Editor</button>
      </div>

      <div class="mb-3">
        <div class="label">Execution Log</div>
        <pre id="log" class="mt-2" style="height:150px;overflow:auto;background:#040404;padding:.6rem;border-radius:.5rem;border:1px solid rgba(255,255,255,0.02)"></pre>
      </div>

      <div class="mt-2 text-xs text-neutral-400">
        <div class="label">Sample files & export</div>
        <div class="mt-2">Drop this folder into Netlify or GitHub Pages. Replace the placeholders (assets, links) and point Gumroad/Payhip to handle sales & delivery.</div>
      </div>
    </aside>
  </div>

  <script>
  // Minimal PyRouette DSL parser and stage renderer — demo-quality, production-focused UX model.
  (function(){
    // Grid dimensions helpers
    const letters = ['a','b','c','d','e','f','g','h'];
    const stage = document.getElementById('stage');
    const log = document.getElementById('log');
    const tempoInput = document.getElementById('tempo');
    const chartsInput = document.getElementById('charts');
    const dslEditor = document.getElementById('dsl');

    // --- Coordinate Conversion Helpers ---
    // Converts chess notation (e.g., 'e4') to internal (col, row) [1-8, 1-8]
    function coordToXY(coord) {
      if (!/^[a-h][1-8]$/.test(coord)) return null;
      const col = letters.indexOf(coord[0]) + 1;
      const row = parseInt(coord[1]);
      return { col, row };
    }

    // Converts internal (col, row) to chess notation (e.g., 'e4')
    function xyToCoord(x, y) {
      if (x < 1 || x > 8 || y < 1 || y > 8) return null; // Out of bounds
      const colChar = letters[x - 1];
      return colChar + y;
    }
    // -------------------------------------

    // Build grid (8x8). Top is upstage.
    function buildGrid(){
      stage.innerHTML = '';
      // Grid rows are built from 8 (upstage) down to 1 (downstage)
      for(let r=8;r>=1;r--){
        for(let c=0;c<8;c++){
          const coord = letters[c]+r;
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.coord = coord;
          cell.dataset.col = c+1;
          cell.dataset.row = r;
          const coordMark = document.createElement('div');
          coordMark.className = 'coord';
          coordMark.innerText = coord;
          cell.appendChild(coordMark);
          stage.appendChild(cell);
        }
      }
    }
    buildGrid();

    // State
    const dancers = {}; // id => {coord, el, role}
    let sequence = []; // array of steps {who, to, beats, type}
    let playing = false;
    let playIndex=0;
    let playTimer=null;

    // DSL: lines like:
    // tempo 120
    // dancer A role Pawn pos e2
    // move A to e4 over 8
    // group [A,B,C] rotate around d4 over 8
    function parseDSL(text){
      const lines = text.split(/\n/).map(s=>s.trim()).filter(Boolean);
      sequence = [];
      let tempo = parseInt(tempoInput.value||120,10);

      // Clear existing dancers first
      Object.keys(dancers).forEach(id => dancers[id].el.remove());
      for(const key in dancers) delete dancers[key];

      lines.forEach((ln,i)=>{
        const L=ln.split(/\s+/);
        const cmd=L[0].toLowerCase();
        try{
          if(cmd==='tempo'){
            tempo = parseInt(L[1]||tempo,10);
            tempoInput.value = tempo;
          logLine(`tempo set ${tempo}`);
          }
          else if(cmd==='dancer'){
            // dancer A role Pawn pos e2
            const id=L[1];
            const roleIndex = L.indexOf('role');
            const posIndex = L.indexOf('pos');
            const role = roleIndex>-1 ? L[roleIndex+1] : 'Pawn';
            const pos = posIndex>-1 ? L[posIndex+1] : 'e2';
            if (dancers[id]) throw new Error(`Dancer ID ${id} already defined.`);
            placeDancer(id, pos, role);
            logLine(`placed dancer ${id} as ${role} at ${pos}`);
          } else if(cmd==='move'){
            // move A to e4 over 8
            const who=L[1];
            const toIndex = L.indexOf('to');
            const overIndex = L.indexOf('over');
            const to = toIndex>-1 ? L[toIndex+1] : null;
            const beats = overIndex>-1 ? parseInt(L[overIndex+1],10):8;
            sequence.push({type:'move',who,to,beats});
            logLine(`queued move ${who}→${to} (${beats} beats)`);
          } else if(cmd==='group'){
            // group [A,B] rotate around d4 over 8
            const groupMatch = ln.match(/\[([A-Za-z0-9, ]+)\]/);
            const members = groupMatch ? groupMatch[1].split(',').map(s=>s.trim()) : [];
            const rotate = ln.includes('rotate');
            const aroundMatch = ln.match(/around\s+([a-h][1-8])/);
            const around = aroundMatch ? aroundMatch[1] : null;
            const overMatch = ln.match(/over\s+(\d+)/);
            const beats = overMatch ? parseInt(overMatch[1],10):8;
            if(rotate) sequence.push({type:'group-rotate',members,around,beats});
            logLine(`queued group action: ${members.join(',')} rotate around ${around} (${beats} beats)`);
          } else if(cmd==='annotate'){
            // annotate A note "entrance"
            const who=L[1];
            const noteMatch = ln.match(/note\s+"(.+)"$/);
            const note = noteMatch ? noteMatch[1] : '';
            sequence.push({type:'note',who,note});
            logLine(`queued annotation for ${who}: ${note}`);
          } else if(ln.startsWith('#') || ln.startsWith('//')){
            // Ignore comments
          } else {
            logLine('unknown: '+ln);
          }
        } catch(e){ logLine(`parse error on line ${i+1}: ${e.message}`); }
      });
      // Update dancer state display after parsing
      Object.keys(dancers).forEach(id => {
        const dancer = dancers[id];
        // Re-attach token to its current cell element
        const cell = stage.querySelector(`[data-coord="${dancer.coord}"]`);
        if(cell) cell.appendChild(dancer.el);
      });
    }

    // Place dancer token (or move existing)
    function placeDancer(id,pos,role){
      const cell = stage.querySelector(`[data-coord="${pos}"]`);
      if(!cell) return;
      if(!dancers[id]){
        // Create new dancer token
        const token = document.createElement('div');
        token.className = 'dancer token';
        token.id = 'dancer-'+id;
        token.innerText = id;
        // Reset position styles for cell children
        token.style.position='absolute';
        token.style.transform='translate(-50%,-50%)';
        token.style.left='50%';
        token.style.top='50%';
        token.dataset.role = role;
        dancers[id] = {coord:pos,el:token,role};
        cell.appendChild(token);
      } else {
        // Move existing dancer to new cell
        const token = dancers[id].el;
        token.dataset.role = role;
        dancers[id].role = role;
        cell.appendChild(token);
        dancers[id].coord = pos;
      }
      colorizeByRole(dancers[id]);
    }

    function colorizeByRole(d){
      if(!d) return;
      const base = {Pawn:'#A7F3D0',Rook:'#C7B198',Bishop:'#A78BFA',Knight:'#7DD3FC',Queen:'#FDE68A',King:'#FCA5A5'};
      const color = base[d.role] || '#94A3B8';
      d.el.style.background=color;
      d.el.style.color='#021012';
    }

    function logLine(s){ log.innerText = (new Date().toLocaleTimeString())+' • '+s+"\n"+log.innerText; }

    // Playback
    function playSequence(){
      if(playing) return;
      playing = true;
      // If sequence ended, reset index
      if(playIndex >= sequence.length) playIndex = 0;

      const tempo = parseInt(tempoInput.value||120,10);
      // Time to wait before executing the next move in the sequence (4 beats / measure)
      const stepDelayMs = (60000 / tempo) * 4;

      function step(){
        if(playIndex>=sequence.length){ playing=false; clearInterval(playTimer); logLine('sequence ended'); return; }
        const item = sequence[playIndex++];
        if(item.type==='move'){ doMove(item); }
        else if(item.type==='group-rotate'){ doGroupRotate(item); }
        else if(item.type==='note'){ logLine('NOTE: '+item.who+' - "'+item.note+'"'); }

        // Calculate move duration based on beats for smooth CSS transition
        const beats = item.beats || 4;
        const duration = (60000 / tempo) * beats;

        // Wait for the duration of the current movement before setting the next step timer
        clearInterval(playTimer);
      playTimer = setTimeout(step, duration);
      }

      logLine('playing sequence...');
      step();
    }

    function pauseSequence(){ playing=false; clearTimeout(playTimer); playTimer=null; logLine('paused'); }

    function doMove(item){
      const cell = stage.querySelector(`[data-coord="${item.to}"]`);
      if(!cell){ logLine('invalid target '+item.to); return; }
      const dancer = dancers[item.who];
      if(!dancer){ logLine('unknown dancer '+item.who); return; }

      // Move dancer: CSS transition handles the movement visual
      cell.appendChild(dancer.el);
      dancer.coord = item.to;
      logLine(`${item.who} moved to ${item.to} (${item.beats} beats)`);
    }

    function doGroupRotate(item){
      // Enhanced implementation: Perform a 90-degree clockwise rotation around the center point
      const centerCoord = coordToXY(item.around);
      if (!centerCoord) { logLine('invalid rotation center ' + item.around); return; }

      const newPositions = {};

      item.members.forEach(id => {
        const dancer = dancers[id];
        if (!dancer) return;

        const currentCoord = coordToXY(dancer.coord);

        // 1. Calculate relative coordinates (rX, rY) from center
        const rX = currentCoord.col - centerCoord.col;
        const rY = currentCoord.row - centerCoord.row;

        // 2. Perform 90-degree Clockwise Rotation (rX, rY) -> (rY, -rX)
        // (e.g., if a dancer is 2 steps up and 1 step right from center: (1, 2)
        // new relative position will be 2 steps right and 1 step down: (2, -1))
        const nextRX = rY;
        const nextRY = -rX;

        // 3. Convert back to absolute coordinates
        const nextX = nextRX + centerCoord.col;
        const nextY = nextRY + centerCoord.row;

        // 4. Convert back to chess notation
        const nextCoord = xyToCoord(nextX, nextY);

        if (nextCoord) {
          newPositions[id] = nextCoord;
        } else {
          logLine(`${id} left the stage during rotation (from ${dancer.coord})`);
        }
      });

      // Apply the new positions (CSS transitions handle the visual movement)
      for (const id in newPositions) {
        placeDancer(id, newPositions[id], dancers[id].role);
      }
      logLine(`rotated group ${item.members.join(', ')} 90° clockwise around ${item.around} (${item.beats} beats)`);
    }

    function exportRehearsal(){
      // break sequence into weeks: assume 5 sessions/week, each session 8 measures
      const sessions = [];
      const beatsPerSession = 8*4; // rough, assuming 4 beats per measure
      let current = [];
      let accBeats = 0;
      sequence.forEach(s=>{
        const beats = s.beats||8;
        if(accBeats+beats>beatsPerSession){ sessions.push(current); current=[]; accBeats=0; }
        current.push(s); accBeats+=beats;
      });
      if(current.length) sessions.push(current);
      const payload = {tempo:tempoInput.value, sessions};
      const blob = new Blob([JSON.stringify(payload,null,2)],{type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download='rehearsal-schedule.json'; a.click();
      URL.revokeObjectURL(url);
      logLine('rehearsal exported ('+sessions.length+' sessions)');
    }

    function exportNotation(){
      // export sequence + dancer registry as a simple DSL file
      const out = {dancers:Object.keys(dancers).reduce((acc,k)=>{acc[k]={pos:dancers[k].coord,role:dancers[k].role};return acc},{}) , sequence};
      const blob = new Blob([JSON.stringify(out,null,2)],{type:'application/json'});
      const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='pyrouette-notation.json'; a.click();
      logLine('notation exported');
    }

    // Charts parsing (simple colorization by sign)
    function applyCharts(){
      const raw = chartsInput.value.trim();
      if(!raw) return;
      const parts = raw.split(',').map(s=>s.trim()).filter(Boolean);
      parts.forEach(p=>{
        const m = p.match(/^([A-Za-z0-9]+):\s*([A-Za-z]+)=([A-Za-z]+)$/);
        if(!m) return;
        const id=m[1], key=m[2], val=m[3];
        const signColor = {
          'Aries':'#FCA5A5','Taurus':'#FDE68A','Gemini':'#A7F3D0','Cancer':'#BFDBFE','Leo':'#FAD6A5',
          'Virgo':'#D1FAE5','Libra':'#E9D5FF','Scorpio':'#FBCFE8','Sagittarius':'#C7D2FE','Capricorn':'#E6E6E6','Aquarius':'#93C5FD','Pisces':'#C7F9F2'
        }[val] || '#94A3B8';
        if(dancers[id]) {
        // Apply color directly but keep the role colorization logic for non-chart users
        dancers[id].el.style.background = signColor;
        logLine('chart applied to '+id+': '+val);
        }
      });
    }

    // Hooks
    document.getElementById('exec').addEventListener('click', ()=>{
      parseDSL(dslEditor.value||'');
      applyCharts();
      playIndex = 0; // Reset sequence on re-execute
    });
    document.getElementById('play').addEventListener('click', playSequence);
    document.getElementById('pause').addEventListener('click', pauseSequence);
    document.getElementById('clear').addEventListener('click', ()=>{ dslEditor.value=''; log.innerText=''; });
    document.getElementById('exportSchedule').addEventListener('click', exportRehearsal);
    document.getElementById('exportJSON').addEventListener('click', exportNotation);

    // seed example
    const example = `tempo 110
    dancer A role King pos e2
    dancer B role Queen pos d2
    dancer C role Rook pos c2
    dancer D role Rook pos f2
    dancer E role Bishop pos e3

    // Opening Movement: King and Queen advance
    move A to e4 over 4
    move B to d4 over 4

    // Group rotation around the King's new position
    group [B,C,D,E] rotate around e4 over 8

    // Solo move after formation change
    move A to e5 over 2
    annotate A note "Final tableau, high pose"`;
    dslEditor.value = example;
    parseDSL(example);
  })();
  </script>
</body>
</html>
